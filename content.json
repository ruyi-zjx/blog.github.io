{"pages":[{"title":"","text":"#404","link":"/about/index.html"}],"posts":[{"title":"vue3背后的proxy","text":"vue的核心的实现就是通过数据劫持实现的，当渲染 DOM 的时候，会访问其依赖的数据，那么在这个访问的过程当中就完成了一次依赖记录，即哪部分 DOM 会依赖于这个数据。当这个数据改变的时候，就通知被依赖的 DOM 进行重渲染。以上只是大体思路，比较简单。在 vue1 和 vue2 中，数据劫持是通过Object.definePropertyAPI 去实现的: defineProperty12345678Object.defineProperty(data, 'count', { get() { // 这里收集依赖 }, set() { // `count`改变的时候就会通知依赖作相应的改变 },}); 正如这个 API 的定义，必须作用于一个对象，而且被拦截的 key 值也要先定义，这也是为什么在 vue2 中需要先定义 data 数据才能在模版中使用的原因。而且如果对象的层级比较深，那么需要进行递归对象进行数据劫持，性能上有很大的影响。 在 vue3，通过使用新的 APIProxy很好的解决了上面的问题，先来看一下接口的使用方法： proxy12345678const newData = new Proxy(data, { get() { // 依赖追踪 }, set() { // 触发依赖更新 },}); 可以看到Proxy劫持的是整个对象，并且返回了一个被包装的新的对象，这个新对象中的元素的增删改变化都会被观察到。","link":"/2021/01/06/vue3%E8%83%8C%E5%90%8E%E7%9A%84proxy/"}],"tags":[{"name":"Vue源码","slug":"Vue源码","link":"/tags/Vue%E6%BA%90%E7%A0%81/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","link":"/categories/%E5%89%8D%E7%AB%AF/Vue/"}]}